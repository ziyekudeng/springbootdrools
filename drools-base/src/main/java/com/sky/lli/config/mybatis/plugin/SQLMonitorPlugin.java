package com.sky.lli.config.mybatis.plugin;import com.alibaba.fastjson.JSON;import lombok.extern.slf4j.Slf4j;import org.apache.ibatis.executor.Executor;import org.apache.ibatis.mapping.BoundSql;import org.apache.ibatis.mapping.MappedStatement;import org.apache.ibatis.plugin.*;import org.apache.ibatis.session.ResultHandler;import org.apache.ibatis.session.RowBounds;import java.util.Collection;import java.util.Properties;/** * SQL监控，Mybatis插件 * <p>默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p> * <ul><li>拦截执行器的方法，Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li> * <li>拦截参数的处理，ParameterHandler (getParameterObject, setParameters)</li> * <li>拦截结果集的处理，ResultSetHandler (handleResultSets, handleOutputParameters)</li> * <li>拦截Sql语法构建的处理，StatementHandler (prepare, parameterize, batch, update, query)</li></ul> */@Intercepts({        @Signature(type = Executor.class, method = "update", args = {MappedStatement.class, Object.class}),        @Signature(type = Executor.class, method = "query", args = {                MappedStatement.class,                Object.class,                RowBounds.class,                ResultHandler.class})})@Slf4jpublic class SQLMonitorPlugin implements Interceptor {    //是否监控显示SQL    private static final boolean SHOWSQL = true;    //慢SQL时间阀值，单位毫秒    private static final int SLOWER = 3000;    //大集合监控阀值，单位条    private static final int MAXCOUNT = 80;    /**     * 描述   : MyBatis的SQL监控插件拦截器     *     * @param invocation 调用方法     * @return Object     * @throws Throwable 异常     */    public Object intercept(Invocation invocation) throws Throwable {        MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[0];        //请求参数        Object parameter = null;        if (1 < invocation.getArgs().length) {            parameter = invocation.getArgs()[1];        }        BoundSql boundSql = mappedStatement.getBoundSql(parameter);        String sql = boundSql.getSql();        //执行的sql所在的mapper文件        String resource = mappedStatement.getResource();        //执行sql的dao文件的包名+方法名        String daoMethod = mappedStatement.getId();        //去除sql文中的换行        sql = sql.replace("\n", "").replaceAll("\\s+", " ");        //参数转成json        String params = JSON.toJSONString(parameter);        if (SHOWSQL) {            log.warn("\n" +                            "[SQLMonitorPlugin]SQL监控：{}|{}\n" +//方法                            "执行SQL：\n" +                            "{}\n" +//SQL                            "参数：{}", resource, daoMethod,                    sql, params);        }        try {            //开始时间            long start = System.currentTimeMillis();            Object e = invocation.proceed();            //所用时间            long timeTicket = System.currentTimeMillis() - start;            if (SLOWER < timeTicket) {                log.warn("[SQLMonitorInterceptor]SQL监控：{}|{}，慢SQL（{}/{}ms）{}，参数：{}",                        resource, daoMethod, timeTicket, SLOWER, sql, params);            }            if (e instanceof Collection) {                int ct = ((Collection<?>) e).size();                if (MAXCOUNT < ct) {                    log.warn("[SQLMonitorInterceptor]SQL监控：{}|{}，大集合（{}/{}）{}，参数：{}",                            resource, daoMethod, ct, MAXCOUNT, sql, params);                }            }            return e;        } catch (Exception e) {            log.warn("[SQLMonitorPlugin]SQL监控：{}|{}，执行出错：{}，参数：{}", resource, daoMethod,                    sql, params, e);            throw e;        }    }    public Object plugin(Object target) {        return Plugin.wrap(target, this);    }    @Override    public void setProperties(Properties properties) {        //do someting    }}